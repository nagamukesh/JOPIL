package monitor

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -no-strip -target native -type packet_event bpf ../../bpf/packet_probe.c

import (
	"bytes"
	"errors"
	"log"
	"net"

	"JOPIL/internal/model"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

type PacketMonitor struct {
	InterfaceNames []string
	EventsChan    chan model.PacketEvent
	objs          bpfObjects // generated by bpf2go
	links         []link.Link
	rd            *ringbuf.Reader
}

func New(ifaces []string, eventsChan chan model.PacketEvent) *PacketMonitor {
	return &PacketMonitor{
		InterfaceNames: ifaces,
		EventsChan:    eventsChan,
	}
}

func (pm *PacketMonitor) Start() error {
	if err := rlimit.RemoveMemlock(); err != nil {
		return err
	}

	if err := loadBpfObjects(&pm.objs, nil); err != nil {
		return err
	}

	for _, ifaceName := range pm.InterfaceNames {
		iface, err := net.InterfaceByName(ifaceName)
		if err != nil {
			log.Printf("Warning: Interface %s not found: %v", ifaceName, err)
			continue
		}
		l, err := link.AttachXDP(link.XDPOptions{
			Program:   pm.objs.XdpProbeFunc,
			Interface: iface.Index,
		})
		if err != nil {
			log.Printf("Warning: Failed to attach XDP to %s: %v", ifaceName, err)
			continue
		}
		pm.links = append(pm.links, l)
		log.Printf("Attached XDP to %s", ifaceName)
	}

	if len(pm.links) == 0 {
		return errors.New("failed to attach XDP to any interface")
	}

	var err error
	pm.rd, err = ringbuf.NewReader(pm.objs.Events)
	if err != nil {
		return err
	}

	go pm.readLoop()

	return nil
}

func (pm *PacketMonitor) readLoop() {
	var event model.PacketEvent
	packetCount := 0
	for {
		record, err := pm.rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				return
			}
			log.Printf("Ringbuf read error: %v", err)
			continue
		}

		if err := event.Decode(bytes.NewReader(record.RawSample)); err != nil {
			log.Printf("Event decode error: %v", err)
			continue
		}

		packetCount++
		if packetCount%100 == 0 || packetCount <= 5 {
			log.Printf("Packet #%d: %s:%d -> %s:%d (%s)",
				packetCount,
				event.SAddr, event.SPort, event.DAddr, event.DPort,
				getProtoName(event.Protocol))
		}

		select {
		case pm.EventsChan <- event:
		default:
		}
	}
}

func getProtoName(proto uint8) string {
	switch proto {
	case 6:
		return "TCP"
	case 17:
		return "UDP"
	case 1:
		return "ICMP"
	default:
		return "OTHER"
	}
}

func (pm *PacketMonitor) Close() {
	if pm.rd != nil {
		pm.rd.Close()
	}
	for _, l := range pm.links {
		l.Close()
	}
	pm.objs.Close()
}